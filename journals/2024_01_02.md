- Started planning on the [[Flutter]] and [[Rust]] powered key-stroke launcher.
	- Met some road blocks on the planning phase
		- Though [[Flutter]] has good support for native file system access. Indexing a whole file system with the built-in file system API's to slow and not feasible.
		- Also there is a vast difference between [[Windows]], [[macOS]] and [[Linux]] file-system api's in [[Flutter]].
		- Also storing large amount of file system index data in [[Dart]] based can incur large [[GC]] cost making the application slow.
	- Fixes for the road blocks
		- Solution for the road block is to offload most of the processing to a native more preformat layer with more low level control over the system.
		- Building the application in two layers using a [[Rust]] based logic and processing layer.
			- With the help of [[Rust]] we have no [[GC]] to worry about.
			- [[Rust]] has a great file system watcher package [[notify-rs]] to track file system changes.
			- Also will solve the index data storage problem with [[tantivy]] a rock solid and light weight search library.
		- The gap between [[Flutter]] and [[Rust]] will be bridged using [[Rinf]].
- Looked into how to do real-time on top of DB's there are to approaches.
	- [[CDC]] approach with a tool like [[Debezium]] the reading the [[WAL]] which is easy method. But some DB's and providers don't support this and some hosted provides don't give access to the [[WAL]].
	- Query invalidation approach which is much more complex. This we create a live query through a query engine get real-time updates. Then we route all the write queries through the query engine if the writes have a effect on the subscribed real-time queries we send the update to the client with the new dataset which was written to DB. This approach doesn't depend on any [[WAL]] to track data changes.
		- Problems with query invalidation approach.
			- There is no existing [[Open Source]] implementation to build upon or take as reference.
			- Also tracking Side effect from queries reliably is difficult and doing this at scale at scale would be more difficult.
			- Also this would do at-most once delivery so like in [[Debezium]] we can't replay changes to guarantee delivery.It is possible to implement at-least once delivery but it would be complex.