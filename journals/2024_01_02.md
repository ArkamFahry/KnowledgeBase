- Started planning on the [[Flutter]] and [[Rust]] powered key-stroke launcher.
	- Met some road blocks on the planning phase
		- Though [[Flutter]] has good support for native file system access. Indexing a whole file system with the built-in file system API's to slow and not feasible.
		- Also there is a vast difference between [[Windows]], [[macOS]] and [[Linux]] file-system api's in [[Flutter]].
		- Also storing large amount of file system index data in [[Dart]] based can incur large [[GC]] cost making the application slow.
	- Fixes for the road blocks
		- Solution for the road block is to offload most of the processing to a native more preformat layer with more low level control over the system.
		- Building the application in two layers using a [[Rust]] based logic and processing layer.
			- With the help of [[Rust]] we have no [[GC]] to worry about.
			- [[Rust]] has a great file system watcher package [[notify-rs]] to track file system changes.
			- Also will solve the index data storage problem with [[tantivy]] a rock solid and light weight search library.
		- The gap between [[Flutter]] and [[Rust]] will be bridged using [[Rinf]].
- Looked into how to do real-time on top of DB's there are to approaches.
	- [[CDC]] approach with a tool like [[Debezium]] the reading the [[WAL]] which is easy method. But some DB's and providers don't support this and some hosted provides don't give access to the [[WAL]].
	- Query invalidation approach which is much more complex. This we create a live query through a query engine get real-time updates. Then we route all the write queries through the query engine if the writes have a effect on the subscribed real-time queries we send the update to the client with the new dataset which was written to DB. This approach doesn't depend on any [[WAL]] to track data changes.
		- Problems with query invalidation approach.
			- There is no existing [[Open Source]] implementation to build upon or take as reference.
			- Also tracking Side effect from queries reliably is difficult and doing this at scale at scale would be more difficult.
			- Also this would do at-most once delivery so like in [[Debezium]] we can't replay changes to guarantee delivery. It is possible to implement at-least once delivery but it would be complex.
	- Real-time on DB conclusion
		- Building on top of [[CDC]] and [[Debezium]] leveraging existing battle tested technologies is the safe route. Building a wrapper on [[Debezium]] supporting [[SSE]], [[WebSocket]], [[WebTransport]], [[HTTP Streaming]] etc. This would be the easy path by leveraging existing technology but with the downside of running a heavy service like [[Debezium]] and [[Kafka Connect]].
		- Build a completely custom [[CDC]] engine in [[Rust]] with pluggable data connectors for databases. Upside of this approach is complete control over the [[CDC]] engine and ability to build integrations and support protocols like [[SSE]], [[WebSocket]], [[WebTransport]], [[HTTP Streaming]] easily and also being a single [[Rust]] binary means it would be efficient for operation and maintenance. Downside would be it would take a lot of resources to build a scalable, fast and reliable production ready [[CDC]] engine.
		- Build a real-time query engine which can route queries through it detect changes done by the query and  update the live subscription queries if the write query effected them. This would be the hardest to achieve but the most flexible one because no dependence on [[CDC]]. The primary issues is there is no reference project or any implementation of this kind of real-time  query engine in the [[Open Source]] world. So building this would be a huge undertaking. Making it scalable, fast and reliable would be a another big challenge. We also have to think how to detect changes that are done directly to DB and not through the real-time query engine. How to detect changes fault tolerantly like when a write fails it shouldn't show a false positive and re-compute the real-time query or a success write fails to trigger a re-compute of the real-time query. After the write is committed DB fails so we would need to remember the last change which was pushed out. Most of these would be need to implemented with data flow and incremental compute queries so the system would be fast. So there is a lot of things to think about when creating this type of system and this would be the hardest of all three systems because there can be a massive amount of edge cases. If this type of system is built it means with a pluggable DB and Query Engine this would be able to give real-time on any DB which would be powerful